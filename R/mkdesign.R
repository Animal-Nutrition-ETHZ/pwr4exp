#' Create any design
#'
#' A design can be created if a data frame, a model formula, and other parameters are provided.
#'
#' @param formula a right-hand-side formula to be used for testing treatment effects.
#' This formula follows the same syntax used in the lme4 package to specify fixed and random effects.
#' @param data a data frame containing all independent variables specified in the model,
#' which mirrors the structure of the data generated by the design
#' @param beta a vector of model coefficients.
#' The coefficients of factor variables are the coefficients of dummy variables created using "contr.treatment".
#' This is an optional input of fixed effects.
#' @param means a vector of marginal means or conditioned means if factors have interaction.
#' Regression coefficients are required for numerical variables. Either `beta` or `means` is required as input.
#' A template can be created when `template = TRUE`, or when only the formula and data are provided.
#' This will display the model coefficients or means, along with their respective order in the input, as needed.
#' @param vcomp a vector of variance-covariance components for random effects.
#' A template can also be created when `template = TRUE`, or when only the formula and data are provided.
#' The template represents a variance-covariance matrix, with the values indicating the order of the corresponding variance-covariance parameters that is required in vcomp.
#' @param sigma2 error (residual) variance
#' @param correlation correlation structures, \code{corClasses} in \code{nlme}.
#' @param REML default, TRUE
#' @param template if TRUE, a template for `beta`, `means`, and `vcomp` is
#' generated to indicate the orders of inputs
#' @param ... other arguments passed to internal functions
#'
#' @return a list with critical components of the design needed for power calculation
#' @export
#'
#' @examples
#' # create a data frame,
#' ## representing a CRD with repeated measures at 8 time points
#'
#' n_subject = 6
#' n_trt = 3
#' n_hour = 8
#' trt = c("CON", "TRT1", "TRT2")
#'
#' df.rep <- data.frame(
#'   subject = as.factor(rep(seq_len(n_trt*n_subject), each = n_hour)),
#'   hour = as.factor(rep(seq_len(n_hour), n_subject*n_trt)),
#'   trt = rep(trt, each = n_subject*n_hour)
#' )
#'
#' # templates
#' temp <- mkdesign(formula = ~ trt*hour, data = df.rep)
#' temp$fixeff
#' temp$vcov
#'
#' # create the design
#'
#' design.rep <- mkdesign(
#'   formula = ~ trt*hour,
#'   data = df.rep,
#'   means =  c(1, 2.50, 3.5,
#'              1, 3.50, 4.54,
#'              1, 3.98, 5.80,
#'              1, 4.03, 5.4,
#'              1, 3.68, 5.49,
#'              1, 3.35, 4.71,
#'              1, 3.02, 4.08,
#'              1, 2.94, 3.78),
#'   sigma2 = 2,
#'   correlation = corAR1(value = 0.6, form = ~ hour|subject)
#' )
#'
#' pwr.anova(design.rep)
#'
mkdesign <- function(
    formula,
    data,
    beta = NULL,
    means = NULL,
    vcomp = NULL,
    sigma2 = NULL,
    correlation = NULL,
    REML = TRUE,
    template = FALSE,
    ...
) {

  # FIXME: more robust way?
  rownames(data) <- 1:nrow(data)

  if (is.null(beta) & is.null(means) & is.null(sigma2))
    template <- TRUE
  mc <- mf <- match.call()
  if (length(formula) > 2) {
    formula <- update(formula, NULL ~ .)
    warning(sprintf("Only rhs formula is required\nformula coerced to: %s.", deparse(formula)),  call. = F)
  }
  # FIXME: potential error: if "y" is the name of one of predictors.
  formula <- update(formula, y ~ .)
  data[["y"]] <- numeric(nrow(data))
  mf$formula <- formula
  mf$data <- data
  mf[[1]] <- quote(designStr)
  m <- match(c("formula", "data", "REML", "subset", "weights", "na.action", "offset", "contrast", "control"),
             names(mf), 0L)
  mf <- mf[c(1L, m)]
  desStr <- eval(mf, parent.frame(1L))
  desStr$fixed.frame <- model.frame(lme4::nobars(formula), desStr$frame)

  L <- means2beta_contrasts(desStr)

  if (template) {
    beta <- numeric(ncol(desStr$X))
    fixeff <- means2beta(L, beta = beta)
    fixeff <- lapply(fixeff, function(x) setNames(seq_along(x), names(x)))
    varcov = desStr$reTrms$G_temp
    return(list(fixeff = fixeff, varcov = varcov))
  }

  fixeff <- means2beta(L, means, beta)
  desStr$beta <- fixeff$beta
  desStr$means <- fixeff$means

  if (!is.null(desStr$reTrms)) {
    desStr$reTrms$G@x <- vcomp[desStr$reTrms$Gind]
  }

  # FIXME: add flexibility for "bad" data
  corcall <- mc$correlation
  desStr$rTrms <- corStr(data, sigma2, corcall)

  varpar <- c(vcomp, eval(corcall$value), sigma2)
  desStr$vcov_beta <- vcovbeta_vp(varpar, desStr)

  # FIXME: ML information matrix
  info_mat <- informat(varpar = varpar, desStr = desStr)
  desStr$vcov_varpar <- solve(info_mat)

  Jac <- numDeriv::jacobian(vcovbeta_vp, x = varpar, desStr = desStr)
  # gradient matrices of vcov(beta) w.r.t. variance paramters
  desStr$Jac_list <- lapply(1:ncol(Jac), function(i)
    array(Jac[, i], dim=rep(ncol(desStr$X), 2)))
  return(desStr)
}
